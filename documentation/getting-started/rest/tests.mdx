---
sidebarTitle: Tests
title: Tests
description: Tests are executed after a response is received from the server. You can add multiple tests to a request. You can add tests to both requests saved and not saved in a collection.
---

## Scripts

API Lab lets you add dynamic behavior to REST requests. This allows you to write test suites and build requests that can contain dynamic parameters. You can add JavaScript code that executes at two events in the flow:

<Tip> 
  API Lab supports **Visual Mode** for creating tests for better user experience without the need to write code.
</Tip>

- Tests are executed after a response is received from the server
- You can add multiple tests to a request
- You can add tests to both requests saved and not saved in a collection

<Tip>API Lab will then execute the scripts after the response is received.</Tip>

## Post-request tests

As you introduce new code, tests ensure that your API is working as intended. The higher your test coverage, the more flexible and bug-resistant your code will be. You'll be spending less time wondering why [deleting a picture of a coconut breaks your code](https://www.thegamer.com/this-coconut-jpg-in-team-fortress-2s-game-files-if-deleted-breaks-the-game-and-no-one-knows-why).

## Writing post-request tests

API Lab ships a powerful API called `pm` which can handle post-request scripts as well as tests. Here we'll use `pm` to run tests on the response received from APIs.

**Visual Mode** in API Lab is a powerful tool that allows you to create tests without writing code. It is a visual interface that allows you to create tests by dragging and dropping blocks.

## Examples

Let us look at some examples of how you can use API Lab to write tests.

### Test response status code

Let us write a test to check whether the response to our request has a status code of 200. Which means that there are no errors in the response body. We'll use the below URL with the GET method.

```
https://www.httpbin.org/status/200
```

In this case, we'll need to write two expect statements one for checking the status and another for checking the response body. However, we can wrap expect statements with the `test` method from the `pm` API to group related statements.

There are two ways to test the status code:

| Condition                       | Code                                           |
| ------------------------------- | ---------------------------------------------- |
| Check if response code is `200` | `pm.expect(pm.response.code).to.equal(200)`    |
| Check if response code is less than `500` | `pm.expect(pm.response.code).to.be.below(500)` |

<CodeGroup>
  ```javascript Response code 200
 pm.test("Status code is 200", function () {
    pm.expect(pm.response.code).to.equal(200);
});
  ```
  ```javascript Matcher function
  pm.test("Status code is less than 500", function () {
    pm.expect(pm.response.code).to.be.below(500);
});
  ```
</CodeGroup>

The tests will have passed once you click on the "**Send**" button.

### Assert response payload

In this example, we test whether a user id points to a particular user.
Let us use the following GET API endpoint

```
https://petstore.swagger.io/v2/pet
```

We will use `.to.have.property()` to assert specific values as shown in the code snippet below:

<Tabs>
<Tab title="JavaScript">
```javascript
pm.test("Response body validation", function () {
    const responseJson = pm.response.json();

    // Check required fields
    pm.expect(responseJson).to.have.property('id');
    pm.expect(responseJson).to.have.property('name');
});
```

</Tab>
<Tab title="Visual Mode">
<Frame>
    <img src="/images/apilab/post-script-2.gif" /> 
</Frame>
</Tab>
</Tabs>

Running the test will produce the result as shown below:

```json
  {
  "category": {
    "id": 1,
    "name": "Test Name"
  },
  "id": 1,
  "name": "doggie",
  "photoUrls": [
    "https://example.com"
  ],
  "status": "available",
  "tags": [
    {
      "id": 1,
      "name": "Test Name"
    }
  ]
}
```